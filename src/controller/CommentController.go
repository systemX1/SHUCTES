package controller

import (
	. "SHUCTES/src/database"
	. "SHUCTES/src/log"
	"github.com/gin-gonic/gin"
	"net/http"
)

func GetUserCommentedCourseHandler() gin.HandlerFunc {
	return func(c *gin.Context) {
		username, ok := c.GetQuery("username")
		if !ok {
			c.JSON(http.StatusBadRequest,gin.H{"msg":     "Query wrong"})
			return
		}

		sql := `
SELECT course.uid, course.name, course.teachname, comment.content
FROM ctes.comment, ctes.course
WHERE comment.course_uid = course.uid
AND username = ?; `

		rows, err := DB.Query(sql, username)
		if err != nil {
			Logger.Errorf("While querying: " + err.Error())
			c.JSON(http.StatusInternalServerError,  gin.H{"msg": "server error"})
			return
		}

		type AutoGenerated struct {
			CourseUid	string	`json:"course_uid"`
			CourseName	string 	`json:"course"`
			TeachName	string 	`json:"teachname"`
			Comment 	string 	`json:"content"`
		}
		var jsonSent AutoGenerated
		retSlice :=  make([]AutoGenerated, 0)

		for rows.Next() {
			if err := rows.Scan(&jsonSent.CourseUid, &jsonSent.CourseName, &jsonSent.TeachName, &jsonSent.Comment); err != nil {
				Logger.Errorf("While scanning rows: " + err.Error())
				c.JSON(http.StatusInternalServerError,  gin.H{"msg": "server error"})
				return
			} else {
				retSlice = append(retSlice, jsonSent)
			}
		}
		rows.Close()

		c.JSON(http.StatusOK, gin.H{
			"content":	retSlice,
			"length": 	len(retSlice),
			"msg":     "Request successful",
		})
	}
}

func AddCourseCommentHandler() gin.HandlerFunc {
	return func(c *gin.Context) {
		username, ok := c.GetQuery("username")
		if !ok {
			c.JSON(http.StatusBadRequest,gin.H{"msg":     "Query wrong"})
			return
		}

		type AutoGenerated struct {
			CourseUid	string	`json:"course_uid"`
			Content 	string 	`json:"content"`
		}
		var jsonReci AutoGenerated

		if err := c.BindJSON(&jsonReci); err != nil {
			Logger.Errorf("While binding json to struct: " + err.Error())
			c.JSON(http.StatusBadRequest, gin.H{"msg": "Query wrong"})
			return
		} else {
			Logger.Infof("Handling Requset, Username: %s, JsonReci = %#v", username, jsonReci)

			sql := `
			INSERT INTO ctes.comment(comment.username, comment.course_uid, comment.content) 
			SELECT ?, ?, ?;`

			stmt, err := DB.Prepare(sql)
			if err != nil {
				Logger.Errorf("While preparing sql: " + err.Error())
				c.JSON(http.StatusInternalServerError, gin.H{"msg": "server error"})
				return
			}
			res, err := stmt.Exec(username, jsonReci.CourseUid, jsonReci.Content)
			if err != nil {
				Logger.Errorf("While executing sql: " + err.Error())
				c.JSON(http.StatusForbidden, gin.H{"msg": "Duplicate key or other error while querying"})
				return
			}
			lastId, err := res.LastInsertId()
			if err != nil {
				Logger.Errorf("While getting sql result: " + err.Error())
				c.JSON(http.StatusInternalServerError, gin.H{"msg": "server error"})
				return
			}
			rowCnt, err := res.RowsAffected()
			if err != nil {
				Logger.Errorf("While getting sql rowsAffected: " + err.Error())
				c.JSON(http.StatusInternalServerError, gin.H{"msg": "server error"})
				return
			}
			Logger.Infof("Username: %s, JsonReci = %#v, ID = %d, affected = %d\n", username, jsonReci ,lastId, rowCnt)
			c.JSON(http.StatusOK, gin.H{"msg": "request successful"})
		}
	}
}

func UpdateCourseCommentHandler() gin.HandlerFunc {
	return func(c *gin.Context) {
		username, ok := c.GetQuery("username")
		if !ok {
			c.JSON(http.StatusBadRequest,gin.H{"msg":     "Query wrong"})
			return
		}

		type AutoGenerated struct {
			CourseUid	string	`json:"course_uid"`
			Content		string	`json:"content"`
		}
		var jsonReci AutoGenerated

		if err := c.BindJSON(&jsonReci); err != nil {
			Logger.Errorf("While binding json to struct: " + err.Error())
			c.JSON(http.StatusBadRequest,gin.H{
				"msg":     "Query wrong",
			})
		} else {
			Logger.Infof("Handling Requset, Username: %s, JsonReci = %#v", username, jsonReci)

			sql := `
			UPDATE ctes.comment
			SET comment.content = ?
			WHERE comment.course_uid = ?
			AND comment.username = ?;`
			result, err := DB.Exec(sql, jsonReci.Content, jsonReci.CourseUid, username)

			if err != nil{
				Logger.Errorf("While executing sql: " + err.Error())
				c.JSON(http.StatusInternalServerError,  gin.H{"msg": "server error"})
				return
			} else {
				Logger.Infof("Update success, Username: %s, JsonReci = %#v", username, jsonReci)
			}

			rowaffected, err := result.RowsAffected()
			if err != nil {
				Logger.Errorf("Get RowsAffected failed: " + err.Error())
				c.JSON(http.StatusInternalServerError,  gin.H{"msg": "server error"})
			} else {
				Logger.Infof("Affected rows: %d", rowaffected)
				c.JSON(http.StatusOK,  gin.H{"msg": "request successful"})
			}
		}
	}
}

func DeleteCourseCommentHandler() gin.HandlerFunc {
	return func(c *gin.Context) {
		username, ok := c.GetQuery("username")
		if !ok {
			c.JSON(http.StatusBadRequest,gin.H{"msg":     "Query wrong"})
			return
		}

		type AutoGenerated struct {
			CourseUid	string	`json:"course_uid"`
		}
		var jsonReci AutoGenerated

		if err := c.BindJSON(&jsonReci); err != nil {
			Logger.Errorf("While binding json to struct: " + err.Error())
			c.JSON(http.StatusBadRequest, gin.H{"msg": "Query wrong"})
			return
		} else {
			Logger.Infof("Handling Requset, Username: %s, JsonReci = %#v", username, jsonReci)

			sql := `
			DELETE FROM ctes.comment
			WHERE comment.username = ?
			AND comment.course_uid = ?;`
			result, err := DB.Exec(sql, username, jsonReci.CourseUid)

			if err != nil{
				Logger.Errorf("While executing sql: " + err.Error())
				c.JSON(http.StatusInternalServerError,  gin.H{"msg": "server error"})
				return
			} else {
				Logger.Infof("Update success, Username: %s, JsonReci = %#v", username, jsonReci)
			}

			rowaffected, err := result.RowsAffected()
			if err != nil {
				Logger.Errorf("Get RowsAffected failed: " + err.Error())
				c.JSON(http.StatusInternalServerError,  gin.H{"msg": "server error"})
			} else {
				Logger.Infof("Affected rows: %d", rowaffected)
				c.JSON(http.StatusOK,  gin.H{"msg": "request successful"})
			}
		}
	}
}
